// Code generated by aocgen; DO NOT EDIT.
package year2023

import (
	"sort"
	"strconv"
	"strings"
)

type Day07 struct{}

var cardValuesPartTwo = map[string]int{
	"J": 1,
	"2": 2,
	"3": 3,
	"4": 4,
	"5": 5,
	"6": 6,
	"7": 7,
	"8": 8,
	"9": 9,
	"T": 10,
	"Q": 11,
	"K": 12,
	"A": 13,
}
var cardValues = map[string]int{
	"2": 1,
	"3": 2,
	"4": 3,
	"5": 4,
	"6": 5,
	"7": 6,
	"8": 7,
	"9": 8,
	"T": 9,
	"J": 10,
	"Q": 11,
	"K": 12,
	"A": 13,
}

type HandType int64

const (
	HighCard HandType = iota + 1
	OnePair
	TwoPair
	ThreeOfAKind
	FullHouse
	FourOfAKind
	FiveOfAKind
)

func GetHandType(cards []string, isPartTwo bool) HandType {
	charsMap := map[string]int{}

	for _, card := range cards {
		charsMap[card]++
	}

	if isPartTwo {
		numJs := charsMap["J"]
		if numJs == 5 {
			return FiveOfAKind
		}

		delete(charsMap, "J")
	}

	keys := []string{}
	for key, _ := range charsMap {
		keys = append(keys, key)
	}

	if len(charsMap) == 1 {
		return FiveOfAKind
	}
	if len(charsMap) == 2 {
		if charsMap[keys[0]] == 4 || charsMap[keys[1]] == 4 {
			return FourOfAKind
		} else if (charsMap[keys[0]] == 3 && charsMap[keys[1]] == 2) || (charsMap[keys[0]] == 2 && charsMap[keys[1]] == 3) {
			return FullHouse
		}
	}

	if len(charsMap) == 3 {
		if charsMap[keys[0]] == 3 || charsMap[keys[1]] == 3 || charsMap[keys[2]] == 3 {
			return ThreeOfAKind
		} else if (charsMap[keys[0]] == 2 && charsMap[keys[1]] == 2) || (charsMap[keys[0]] == 2 && charsMap[keys[2]] == 2) || (charsMap[keys[1]] == 2 && charsMap[keys[2]] == 2) {
			return TwoPair
		}
	}

	if len(charsMap) == 4 {
		return OnePair
	}

	return HighCard
}

type Hand struct {
	Cards []string
	Bet   int
	Type  HandType
}

// TODO Distribute into map of types
func (p Day07) PartA(lines []string) any {
	hands := []Hand{}
	for _, line := range lines {
		if line == "" {
			continue
		}
		parts := strings.Split(line, " ")
		cards := strings.Split(parts[0], "")
		bid, _ := strconv.Atoi(parts[1])
		hands = append(hands, Hand{
			Cards: cards,
			Bet:   bid,
			Type:  GetHandType(cards, false),
		})
	}

	sort.Slice(hands, func(i, j int) bool {
		handI := hands[i]
		handJ := hands[j]

		if handJ.Type == handI.Type {
			for idx := 0; idx < 5; idx++ {
				handICardValue := cardValues[handI.Cards[idx]]
				handJCardValue := cardValues[handJ.Cards[idx]]
				if handICardValue == handJCardValue {
					continue
				}

				if handICardValue < handJCardValue {
					return true
				}

				return false
			}
		}

		return handI.Type < handJ.Type
	})

	sum := 0
	for i, hand := range hands {
		sum += (i + 1) * hand.Bet
	}
	return sum
}

func (p Day07) PartB(lines []string) any {
	hands := []Hand{}
	for _, line := range lines {
		if line == "" {
			continue
		}
		parts := strings.Split(line, " ")
		cards := strings.Split(parts[0], "")
		bid, _ := strconv.Atoi(parts[1])
		hands = append(hands, Hand{
			Cards: cards,
			Bet:   bid,
			Type:  GetHandType(cards, true),
		})
	}

	sort.Slice(hands, func(i, j int) bool {
		handI := hands[i]
		handJ := hands[j]

		if handJ.Type == handI.Type {
			for idx := 0; idx < 5; idx++ {
				handICardValue := cardValuesPartTwo[handI.Cards[idx]]
				handJCardValue := cardValuesPartTwo[handJ.Cards[idx]]
				if handICardValue == handJCardValue {
					continue
				}

				if handICardValue < handJCardValue {
					return true
				}

				return false
			}
		}

		return handI.Type < handJ.Type
	})

	sum := 0
	for i, hand := range hands {
		sum += (i + 1) * hand.Bet
	}
	return sum
}
