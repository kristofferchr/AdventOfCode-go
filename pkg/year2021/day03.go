// Code generated by aocgen; DO NOT EDIT.
package year2021

import (
	"strconv"
	"strings"
)

type Day03 struct{}

func parseMatrixOfBits(lines []string) [][]int {
	var matrix [][]int
	for _, line := range lines {
		if line == "" {
			continue
		}

		bitRow := strings.Split(line, "")
		var bitRowInts []int
		for _, bit := range bitRow {
			bitInt, err := strconv.Atoi(bit)
			if err != nil {
				panic("Wrong input, expected bit of int, but other type received")
			}

			bitRowInts = append(bitRowInts, bitInt)
		}

		matrix = append(matrix, bitRowInts)
	}
	return matrix
}

func (p Day03) PartA(lines []string) any {
	matrix := parseMatrixOfBits(lines)

	var mostCommonBits []int
	var leastCommonBits []int
	for i := 0; i < len(matrix[0]); i++ {
		countOneBit := 0
		countZeroBit := 0
		for _, row := range matrix {
			bit := row[i]
			switch bit {
			case 0:
				countZeroBit++
			case 1:
				countOneBit++
			}
		}

		if countOneBit > countZeroBit {
			mostCommonBits = append(mostCommonBits, 1)
			leastCommonBits = append(leastCommonBits, 0)
		} else {
			mostCommonBits = append(mostCommonBits, 0)
			leastCommonBits = append(leastCommonBits, 1)
		}

	}

	decimalGamma := bitsArrayToDeciml(mostCommonBits)
	decimalEpsiolon := bitsArrayToDeciml(leastCommonBits)

	return int(decimalEpsiolon * decimalGamma)
}

type Filter int

const (
	MostCommon Filter = iota
	LeastComon
)

func filterBitRows(bits [][]int, columnIndex int, filterMode Filter) [][]int {
	zeroBitRows := [][]int{}
	oneBitRows := [][]int{}

	for _, bitRow := range bits {
		bit := bitRow[columnIndex]
		if bit == 0 {
			zeroBitRows = append(zeroBitRows, bitRow)
		} else {
			oneBitRows = append(oneBitRows, bitRow)
		}
	}

	if filterMode == MostCommon {
		if len(oneBitRows) >= len(zeroBitRows) {
			return oneBitRows
		} else {
			return zeroBitRows
		}
	} else {
		if len(zeroBitRows) <= len(oneBitRows) {
			return zeroBitRows
		} else {
			return oneBitRows
		}

	}

	return nil
}

func bitsArrayToDeciml(bits []int) int64 {
	bitsString := ""
	for _, bitInt := range bits {
		bitsString += strconv.Itoa(bitInt)
	}

	decimal, err := strconv.ParseInt(bitsString, 2, 64)
	if err != nil {
		panic("decimal epsilon was not an int")
	}

	return decimal
}

func (p Day03) PartB(lines []string) any {
	matrix := parseMatrixOfBits(lines)

	oxygenRating := getRating(matrix, MostCommon)
	co2Rating := getRating(matrix, LeastComon)

	return oxygenRating * co2Rating
}

func getRating(matrix [][]int, filter Filter) int {
	filteredMatrix := matrix
	for i := 0; i < len(filteredMatrix[0]); i++ {
		filteredMatrix = filterBitRows(filteredMatrix, i, filter)
		if len(filteredMatrix) == 1 {
			break
		}
	}

	resultingBitRow := filteredMatrix[0]
	return int(bitsArrayToDeciml(resultingBitRow))
}
